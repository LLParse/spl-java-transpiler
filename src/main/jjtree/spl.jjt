options
{
}

PARSER_BEGIN(SPLParser)

package com.dontexist.morals.splparser;

public class SPLParser {
}

PARSER_END(SPLParser)

SPECIAL_TOKEN : {
	  <"--" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	| <"{" (~["}"])* "}">
	| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

SKIP : {
	  " "
	| "\t"
	| "\f"
	| "\r"
	| "\n"
}

TOKEN : {
	  <AS: "as">
	| <CALL: "call">
	| <COMMIT: "commit">
	| <CREATE: "create">
	| <CURRENT: "current">
	| <DBA: "dba">
	| <DEFINE: "define">
	| <EXCEPTION: "exception">
	| <EXECUTE: "execute">
	| <FALSE: "false">
	| <FRACTION: "fraction">
	| <GO: "go">
	| <GRANT: "grant">
	| <LET: "let">
	| <NULL: "null">
	| <ON: "on">
	| <OFF: "off">
	| <FILE: "file">
	| <TRACE: "trace">
	| <DEBUG: "debug">
	| <PROCEDURE: "procedure">
	| <RAISE: "raise">
	| <RETURN: "return">
	| <RETURNING: "returning">
	| <RETURNS: "returns">
	| <REVOKE: "revoke">
	| <ROLLBACK: "rollback">
	| <SECOND: "second">
	| <TO: "to">
	| <TODAY: "today">
	| <TRUE: "true">
	| <WORK: "work">
}

/* OPERATORS */

TOKEN :
{
	  <AND: "and">
	| <OR: "or">
	| <IN: "in">
	| <IS: "is">
	| <LIKE: "like">
	| <MATCHES: "matches">
	| <BETWEEN: "between">
	| <NE: "!=">
	| <NE2: "<>">
	| <GE: ">=">
	| <GT: ">">
	| <EQ: "=">
	| <LE: "<=">
	| <LT: "<">
	| <NOT: "not">
	| <SOME: "some">
	| <ALL: "all">
	| <ANY: "any">
	| <CONCAT: "||">
	| <PLUS: "+">
	| <MINUS: "-">
	| <STAR: "*">
	| <SLASH: "/">
	| <CAST: "::">
	| <UNITS: "units">
}

TOKEN : {
	  <BLOB: "blob">
	| <BOOLEAN: "boolean">
	| <BYTE: "byte">
	| <CHAR: "char">
	| <CHARACTER_VARYING: "character_varying">
	| <CLOB: "clob">
	| <DATE: "date">
	| <DATETIME: "datetime">
	| <DECIMAL: "decimal">
	| <FLOAT: "float">
	| <INT: "int">
	| <INT8: "int8">
	| <INTEGER: "integer">
	| <INTERVAL: "interval">
	| <LVARCHAR: "lvarchar">
	| <MONEY: "money">
	| <NCHAR: "nchar">
	| <NVARCHAR: "nvarchar">
	| <SERIAL: "serial">
	| <SERIAL8: "serial8">
	| <SMALLFLOAT: "smallfloat">
	| <SMALLINT: "smallint">
	| <TEXT: "text">
	| <VARCHAR: "varchar">
}

TOKEN : {
	  <IF: "if">
	| <THEN: "then">
	| <ELIF: "elif">
	| <ELSE: "else">
	| <BEGIN: "begin">
	| <END: "end">
	| <EXIT: "exit">
	| <CONTINUE: "continue">
	| <SWITCH: "switch">
	| <DO: "do">
	| <WHILE: "while">
	| <FOR: "for">
	| <FOREACH: "foreach">
}


TOKEN : {
	  <YEAR: "year">
	| <DAY: "day">
	| <HOUR: "hour">
	| <MONTH: "month">
}

TOKEN : {
	  <DROP: "drop">
	| <TABLE: "table">
	| <TEMP: "temp">
	| <WITH: "with">
	| <HOLD: "hold">
	| <RESUME: "resume">
	| <NO: "no">
	| <LOG: "log">
	| <MODE: "mode">
	| <LOCK: "lock">
	| <SHARE: "share">
	| <EXCLUSIVE: "exclusive">
	| <INSERT: "insert">
	| <INTO: "into">
	| <VALUES: "values">
	| <SELECT: "select">
	| <UNION: "union">
	| <DISTINCT: "distinct">
	| <UPDATE: "update">
	| <DELETE: "delete">
	| <SET: "set">
	| <FROM: "from">
	| <WHERE: "where">
	| <ORDER: "order">
	| <GROUP: "group">
	| <BY: "by">
	| <DESC: "desc">
	| <ASC: "asc">
	| <JOIN: "join">
	| <OUTER: "outer">
	| <INNER: "inner">
	| <LEFT: "left">
	| <EXISTS: "exists">
}

TOKEN : {
	<INTEGER_LITERAL: "0" | (["+","-"])? ["1"-"9"] ( ["0"-"9"] )*>
	| <STRING_LITERAL: 
		"\"" (~["\""])* "\""
		| "\'" (~["\'"])* "\'">
	| <FLOAT_LITERAL:
		<INTEGER_LITERAL> "." ( <INTEGER_LITERAL> )*>
}

TOKEN : {
	  <IDENTIFIER: <LETTER> ( <LETTER> | <DIGIT> )*>
	| <#LETTER: ["a"-"z","A"-"Z","_"]>
	| <#DIGIT: ["0"-"9"]>
}

ASTCompilationUnit CompilationUnit() :
{}
{
	DeclarationList() <EOF>
	{
		return jjtThis;
	}
}

void DeclarationList() #void :
{}
{
	( Declaration() )+
}

void Declaration() :
{}
{
	( ProcedureDeclaration()
	| GrantDeclaration()
	| RevokeDeclaration() )
	( ";" | "go" )*
}

/* Ignore these because we don't care */
void GrantDeclaration() #void :
{}
{
	"grant" "execute" "on" "procedure" [ LOOKAHEAD(2) <IDENTIFIER> "." ] <IDENTIFIER> "to" <IDENTIFIER>
}

void RevokeDeclaration() :
{}
{
	"revoke" "execute" "on" "procedure" [ LOOKAHEAD(2) ( <IDENTIFIER> | <STRING_LITERAL> ) "." ] <IDENTIFIER> [ "." ( <IDENTIFIER> | <STRING_LITERAL> ) ]
	"(" ( LOOKAHEAD(2) PrimitiveTypeList() | ArgumentList() ) ")"  [ ( "returning" | "returns" ) PrimitiveTypeList() ";" ]
	"from" <IDENTIFIER> "as" ( <IDENTIFIER> | <STRING_LITERAL> ) ";"
}

void ProcedureDeclaration() :
{
	Token name;
}
{
	"create" [ "dba" ] "procedure" [ LOOKAHEAD(2) ( <IDENTIFIER> | <STRING_LITERAL> )? "." ] name=<IDENTIFIER> "(" [ ArgumentList() ] ")" [ ( "returning" | "returns" ) PrimitiveTypeList() ] [ LOOKAHEAD(2) ";" ]
	CompoundStatement()
	
	ProcedureConclusion()
	{
		jjtThis.setName(name.image);
	}
}

void ProcedureConclusion() :
{}
{
	"end" "procedure"
}

void ArgumentList() :
{}
{
	Argument() ( "," Argument() )*
}

void Argument() :
{}
{
	Identifier() PrimitiveType()
}

void PrimitiveTypeList() :
{}
{
	PrimitiveType() ( "," PrimitiveType() )*
}

void PrimitiveType() :
{}
{
	{
		Token t;
	}
	[ <IDENTIFIER> "." ]
	( t=<CHAR> | t=<CHARACTER_VARYING> | t=<LVARCHAR> | t=<NCHAR> | t=<NVARCHAR> | t=<VARCHAR>
	| t=<DECIMAL> | t=<FLOAT> | t=<INT> | t=<INT8> | t=<INTEGER> | t=<MONEY> | t=<SERIAL> | t=<SERIAL8> | t=<SMALLFLOAT> | t=<SMALLINT>
	| t=<BYTE> | t=<TEXT> | t=<BLOB> | t=<CLOB>
	| t=<DATE> | t=<DATETIME> | t=<INTERVAL>
	| t=<BOOLEAN> ) [ LOOKAHEAD(2) primitiveTypeParams() ]
	{
		jjtThis.setType(t.image);
	}
}

/* We ignore all data type parameters */
void primitiveTypeParams() #void : {}
{
	  "(" <INTEGER_LITERAL> ( "," <INTEGER_LITERAL> )* ")"
	| intervalParams()
}

void intervalParams() :
{}
{
	intervalParam() "to" intervalParam()
}

void intervalParam() :
{
	Token t;
}
{
	( t="year"
	| t="month"
	| t="day"
	| t="hour"
	| t="second"
	| t="fraction" )
	{
		jjtThis.setParam(t.image);
	}
}

void Identifier() : {}
{
	{
		Token t1, t2 = null, mod = null;
	}
	[ mod="distinct" ] 
	( t1=<IDENTIFIER> [ "." t2=<IDENTIFIER> ] 
	| t1="desc" 
	| t1="year"
	| t1="date"
	| t1="day"
	| t1="month"
	| t1="count") 
	{
		if (t2 == null) {
			jjtThis.setName(t1.image);
		}
		else {
			jjtThis.setName(t1.image.concat(".").concat(t2.image));
		}
		jjtThis.setModifier(mod != null ? mod.image : null);
	}
}

void IdentifierList() :
{}
{
	Identifier() ( LOOKAHEAD(2) "," Identifier() )*
}

void CompoundStatement() :
{}
{
	( Statement() )*
}

void Statement() #void :
{}
{
	
	  DefinitionStatement()
	| ExpressionStatement()
	| IfStatement()
	| ForStatement()
	| ForEachStatement()
	| WhileStatement()
	| ContinueLoopStatement()
	| ExitLoopStatement()
	| TraceStatement()
	| SetDebugFileStatement()
	| ReturnStatement()
	| OnExceptionStatement()
	| RaiseExceptionStatement()
	| LOOKAHEAD(2) BlockStatement()
	| TransactionStatement()
	| SQLStatement()
}

void BlockStatement() :
{}
{
	"begin" CompoundStatement() "end"
}

void DefinitionStatement() :
{}
{
	"define" Identifier() PrimitiveType() ";"
}

void ExpressionStatement() :
{}
{
	Expression() ";"
}

void IfStatement() #void : {}
{
	  IfClause() 
	( ElifClause() )* 
	[ ElseClause() ] 
	  <END> <IF> [ LOOKAHEAD(2) ";" ]
}

void IfClause() :
{}
{
	<IF> [ LOOKAHEAD(2) "(" ] Expression() [ ")" ] <THEN> CompoundStatement()
}

void ElifClause() :
{}
{
	<ELIF> [ LOOKAHEAD(2) "(" ] Expression() [ ")" ] <THEN> CompoundStatement()
}

void ElseClause() :
{}
{
	<ELSE> CompoundStatement()
}

void ForStatement() :
{}
{
	"for" Identifier() "=" Expression() "to" Expression() CompoundStatement() "end" "for" ";"
}

void ForEachStatement() :
{
	Token hold = null;
}
{
	"foreach"
	( LOOKAHEAD(3) [ <IDENTIFIER> [ "with" hold="hold" ] "for" ] SelectExpression()
	| postfixExpression() ) 
	CompoundStatement() "end" "foreach" [ ";" ]
	{
		jjtThis.setHoldability(hold != null);
	}
}

void WhileStatement() : 
{}
{
	<WHILE> "(" Expression() ")" CompoundStatement() <END> <WHILE> [ LOOKAHEAD(2) ";" ]
}

void ContinueLoopStatement() :
{}
{
	"continue" [ "while" | "foreach" ] ";"
}

void ExitLoopStatement() :
{}
{
	"exit" [ "while" | "foreach" ] ";"
}

void TraceStatement() :
{}
{
	"trace" TraceArgument() ";"
}

void TraceArgument() :
{}
{
	{
		Token t;
	}
	  t="on"
	{
		jjtThis.setName(t.image);
	}
	| t="off"
	{
		jjtThis.setName(t.image);
	}
	| t="procedure"
	{
		jjtThis.setName(t.image);
	}
}

void SetDebugFileStatement() :
{}
{
	"set" "debug" "file" "to" Expression() ";"
}

void ReturnStatement() : 
{
	Token resume = null;
}
{
	"return" [ LOOKAHEAD(ExpressionList() ) ExpressionList() [ "with" resume="resume" ] ] ";"
	{
		jjtThis.setResume(resume != null);
	}
}

void OnExceptionStatement() :
{}
{
	"on" "exception" "set" IdentifierList() CompoundStatement() "end" "exception"
}

void RaiseExceptionStatement() :
{}
{
	"raise" "exception" Expression() [ LOOKAHEAD(2) "," Expression() [ LOOKAHEAD(2) "," Expression() ] ] ";"	
}

void TransactionStatement() :
{
	Token t = null;
}
{
	( t="rollback" | t="begin" | t="commit" ) [ "work" ] ";"
	{
		jjtThis.setCommand(t.image);
	}
}

void ExpressionList() : {}
{
	Expression() ( LOOKAHEAD(2) "," Expression() )*
}

void Expression() #void :
{}
{
	assignmentExpression()
}

void assignmentExpression() #assignmentExpression(>1) :
{}
{
	  "let" IdentifierList() "=" ExpressionList()
	| LOOKAHEAD(2) intervalParams()
	| logicalExpression()
}

void logicalExpression() #void : {}
{
	orExpression()
}

void orExpression() #orExpression(>1) : {}
{
	andExpression() [ "or" orExpression() ]
}

void andExpression() #andExpression(>1) : {}
{
	prepositionExpression() [ "and" andExpression() ]
}

/* TODO: Missing BETWEEN...AND */
void prepositionExpression() #prepositionExpression(>1) : 
{
	Token t, not = null;
}
{
	( [ not="not" ] t="exists" "(" SelectExpression() ")"
	{
		String oper = t.image;
		
		if (not != null)
			oper = "not ".concat(oper);
			
		jjtThis.setOperator(oper);
	}
	| comparisonExpression()
	[
		LOOKAHEAD(2) [ not="not" ] 
		( t="in" "(" ( ExpressionList() | SelectExpression() ) ")"
		| t="like" prepositionExpression()
		| t="matches" prepositionExpression()
		| t="between" postfixExpression() "and" postfixExpression() ) 
		{
			oper = t.image;
			
			if (not != null)
				oper = "not ".concat(oper);
				
			jjtThis.setOperator(oper);
		}
	] )
}

void comparisonExpression() #comparisonExpression(>1) : {}
{
	{
		Token t1, t2 = null;
	}
	quantitativeExpression() [ 
	( t1="<" 
	| t1="<=" 
	| t1="=" 
	| t1="==" 
	| t1=">" 
	| t1=">=" 
	| t1="!=" 
	| t1="<>" 
	| t1="is" [t2="not"] )
	{
		String oper = t1.image;
		if (t2 != null)
			oper = oper.concat(" " + t2.image);
			
		jjtThis.setOperator(oper);
	}
	comparisonExpression() ]
}

void notExpression() #notExpression(>1) : {}
{
	quantitativeExpression() [ "not" prepositionExpression() ]
}

void quantitativeExpression() #quantitativeExpression(>1) : {}
{
	concatenationExpression() [ ( "any" | "all" | "some" ) quantitativeExpression() ]
}

void concatenationExpression() #concatenationExpression(>1) : {}
{
	additiveExpression() [ "||" concatenationExpression() ]
}

void additiveExpression() #additiveExpression(>1) : {}
{
	{
		Token t;
	}
	multiplicativeExpression() [
		LOOKAHEAD(2) 
		( t="+" 
			{
				jjtThis.setOperator(t.image);
			}
		| t="-" 
			{
				jjtThis.setOperator(t.image);
			}
		) additiveExpression() ]
}

void multiplicativeExpression() #multiplicativeExpression(>1) : {}
{
	{
		Token t;
	}
	unaryExpression() [ 
		LOOKAHEAD(2)
		( t="*" 
			{
				jjtThis.setOperator(t.image);
			}
		| t="/" 
			{
				jjtThis.setOperator(t.image);
			}
		) multiplicativeExpression() ]
}

void unaryExpression() #unaryExpression(t != null) : 
{
	Token t = null;
}
{
	( postfixExpression()
	| t="+" unaryExpression() 
	| t="-" unaryExpression() )
	{
		if (t != null)
			jjtThis.setOperator(t.image);
	}
}

void postfixExpression() #postfixExpression(>1) : 
{
	Token tProc = null;
}
{
	( unitsExpression() [ "(" ExpressionList() ")" ]
	| tProc="execute" "procedure" Identifier() "(" ExpressionList() ")" [ LOOKAHEAD(2) IntoClause() ]
	| LOOKAHEAD(2) tProc="call" Identifier() "(" [ LOOKAHEAD(ExpressionList() ) ExpressionList() ] ")" [ "returning" ( IdentifierList() ) ] )
	{
		jjtThis.setProcedureCall(tProc != null);
	}
}

void unitsExpression() #unitsExpression(>1) : {}
{
	substringExpression() [ "units" intervalParam() ]
}

void substringExpression() #substringExpression(>1) :
{}
{
	primaryExpression() [ "[" Literal() "," Literal() "]" ]
}

void primaryExpression() #void : {}
{
	  Identifier() 
	| Literal() 
	| NestedExpression()
}

void NestedExpression() :
{}
{
	"(" ( logicalExpression() | SelectExpression() )? ")"
	
}

/****************** LITERALS ********************/

void Literal() :
{}
{
	{
		Token t;
	}
	  t=<INTEGER_LITERAL>
	{
		jjtThis.setName(t.image);
	}
	| t=<STRING_LITERAL>
	{
		jjtThis.setName(t.image);
	}
	| t=<FLOAT_LITERAL>
	{
		jjtThis.setName(t.image);
	}
	| t="true"
	{
		jjtThis.setName(t.image);
	}
	| t="false"
	{
		jjtThis.setName(t.image);
	}
	| t="null"
	{
		jjtThis.setName(t.image);
	}
	| t="current"
	{
		jjtThis.setName(t.image);
	}
	| t="today"
	{
		jjtThis.setName(t.image);
	}
	| t="*"
	{
		jjtThis.setName(t.image);
	}
}

/* SQL Statement Production aggregate */
void SQLStatement() : {}
{
	( dropTableExpression()
	| CreateTableStatement()
	| LockTableExpression()
	| SelectExpression()
	| InsertExpression()
	| UpdateExpression()
	| DeleteExpression()) [ ";" ]
}

void LockTableExpression() :
{
	Token mode;
}
{
	"lock" "table" Identifier() "in" ( mode="exclusive" | mode="share" ) "mode"
	{
		jjtThis.setMode(mode.image);
	}
}

void dropTableExpression() : {}
{
	"drop" "table" Identifier()
}


void CreateTableStatement() :
{}
{
	{
		Token t1 = null;
	}
	"create" [ t1="temp" ] "table" Identifier() "(" [ ArgumentList() ] ")" [ "with" "no" "log" ]
	{
		jjtThis.setModifier(t1 != null ? t1.image : null);
	}
}


void InsertExpression() :
{}
{
	InsertClause()
	( ValuesClause()
	| SelectExpression() )
}

void SelectExpression() :
{}
{
	SelectClause() [ IntoClause() ] FromClause() [ WhereClause() ] [ GroupByClause() ] [ OrderByClause() ]
	[ "union" SelectExpression() ]
}

void UpdateExpression() :
{}
{
	UpdateClause() SetClause() [ WhereClause() ]
}

void DeleteExpression() :
{}
{
	DeleteClause() [ WhereClause() ]
}

void DeleteClause() :
{}
{
	"delete" "from" Identifier()
}

void InsertClause() :
{}
{
	"insert" "into" Identifier() [ "(" IdentifierList() ")" ] 
}

void SelectClause() :
{}
{
	"select" ExpressionList()
}

void UpdateClause() :
{}
{
	"update" Identifier()
}

void FromClause() :
{}
{
	"from" FromExpressionList()
}

void IntoClause() :
{}
{
	"into" IdentifierList()
}

void ValuesClause() :
{}
{
	"values" "(" ExpressionList() ")"
}


void SetClause() :
{}
{
	"set" SetExpressionList()
}

void SetExpressionList() :
{}
{
	SetExpression() ( "," SetExpression() )*
}

void SetExpression() :
{}
{
	  Identifier() "=" Expression()
	| "(" IdentifierList() ")" "=" "(" ExpressionList() ")"
}

void WhereClause() :
{}
{
	"where" logicalExpression()
}

void GroupByClause() :
{}
{
	"group" "by" ( IdentifierList() | Literal() ) 
}

void OrderByClause() :
{}
{
	"order" "by" OrderByExpressionList()
}

void FromExpressionList() :
{}
{
	FromExpression() ( "," FromExpression() )*
}

void FromExpression() :
{
	Token tOuter = null;
	Token tInner = null;
}
{
	( LOOKAHEAD(2) "(" SelectExpression() ")"
	| tOuter="outer" TableDecl() 
	| TableDecl() ( tInner="inner" "join" TableDecl() "on" logicalExpression() )* )
	{
		jjtThis.setOuter(tOuter != null);
		jjtThis.setInner(tInner != null);
	}
}

void OrderByExpressionList() :
{}
{
	OrderByExpression() ( "," OrderByExpression() )*
}

void OrderByExpression() :
{
	Token modifier = null;
}
{
	( Identifier() | Literal() ) [ modifier="asc" | modifier="desc" ]
	{
		jjtThis.setModifier(modifier != null ? modifier.image : null);
	}
}

void TableDeclList() :
{}
{
	TableDecl() ( "," TableDecl() )*
}

void TableDecl() :
{}
{
	[ "(" ] Identifier() [ LOOKAHEAD(2) Identifier() ] [ LOOKAHEAD(2) ")" ]
}

void AssignmentStatementList() : {}
{
	AssignmentStatement() ( "," AssignmentStatement() )*
}

void AssignmentStatement() : {}
{
	
	( LOOKAHEAD(3) postfixExpression() "=" Expression()
	| "(" Identifier() ( "," Identifier() )+ ")" "=" "(" Expression() ( "," Expression() )+ ")" )
}
